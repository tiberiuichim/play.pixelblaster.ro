<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker Compose on The Plone Expanse</title>
    <link>/tags/docker-compose/index.xml</link>
    <description>Recent content in Docker Compose on The Plone Expanse</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>@2016 Tiberiu Ichim</copyright>
    <atom:link href="/tags/docker-compose/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Easier development when dealing with docker-compose stacks</title>
      <link>/blog/2016/12/13/easier-development-when-dealing-with-docker-compose-stacks/</link>
      <pubDate>Tue, 13 Dec 2016 09:26:44 -0100</pubDate>
      
      <guid>/blog/2016/12/13/easier-development-when-dealing-with-docker-compose-stacks/</guid>
      <description>&lt;p&gt;For some time I&#39;ve had to deal with two separate, docker-compose based application stacks. One of them combining a Ruby on Rails app with a whole suite of ElasticSearch nodes, sidekiq worker, Postgresql, nginx, the whole shebang. Another is just a plain Zope/Plone stack, but the difficulties remain the same: when I wanted to do production debugging or just plain development using that environment, I needed something that can be started manually, in the whole stack. I don&#39;t want to have to deal with &lt;a class=&#34;external-link&#34; href=&#34;https://pypi.python.org/pypi/rpdb/&#34;&gt;rpdb&lt;/a&gt;&amp;nbsp;or remote byebug just to be able to debug. I want to poke around the whole stacks and see what happens.&amp;nbsp;&lt;/p&gt;
&lt;p&gt;So my solution was, in both cases, to configure another service in the docker-compose stack that just did nothing.&lt;/p&gt;
&lt;pre&gt;...
debug:
 &amp;nbsp;image: plone
 &amp;nbsp;ports:
 &amp;nbsp;&amp;nbsp;&amp;nbsp;- &#34;8090:8080&#34;
 &amp;nbsp;volumes:
 &amp;nbsp;&amp;nbsp;&amp;nbsp;- ./src:/plone/instance/src
 &amp;nbsp;entrypoint: sh -c &#34;tail -f /dev/null&#34;
&lt;/pre&gt;
&lt;p&gt;Something like the above. Notice the entry point, which just keeps the container up, but does nothing. Now I can run&lt;/p&gt;
&lt;pre&gt;docker exec -it debug_1 bash&lt;/pre&gt;
&lt;p&gt;And inside the container, I can edit the eggs to set a pdb.trace() line whereever, then start the instance:&amp;nbsp;&lt;/p&gt;
&lt;pre&gt;bin/standalone fg&lt;/pre&gt;
&lt;p&gt;Why go through this trouble instead of just running the plone container with something like&lt;/p&gt;
&lt;pre&gt;docker run --name debug plone&lt;/pre&gt;
&lt;p&gt;Usually docker-compose stack are entertwined services that need connecting to one another. My given service debug could be linked to whatever other service: postfix, postgresql, elasticsearch, etc. Why go through the trouble of linking manually, from the command line, when I can just get docker-compose to do it?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>