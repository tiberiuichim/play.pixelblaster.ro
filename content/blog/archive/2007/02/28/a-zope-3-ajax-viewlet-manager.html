+++
draft = false
date = "2007-02-28T19:24:51-02:00"
title = "A Zope 3 AJAX viewlet manager"
keywords = "AJAX, cookbook, zope3"
created = "2007-02-28T18:47:27-02:00"
modified = "2007-02-28T19:40:02-02:00"
permaLink = "http://play.pixelblaster.ro/blog/archive/2007/02/28/a-zope-3-ajax-viewlet-manager"
author = "Tiberiu Ichim"
+++

<p>I've finally got tired of writing small fragments of JavaScript code and views to be able to make different areas updatable through ajax for my current Zope 3 application. Plus, when I've started writing this application, I've started doing the layout with viewlets and managers, and it seems that for each viewlet that I'm creating I have to have a way to get its content through AJAX, which means having a page available for it, and this is very odd, as it almost defeats the point of having viewlets.</p><p>So I've decided to create the "Ajax viewlet manager". I'm not sure how good of an idea this is, I'll have to give it some thought and see how I feel about it in the future. Let me describe my solution.</p><p>First, I want to be able to have the manager available at a certain URL, to be able to reload this URL through an Ajax call later on. So I've created a new namespace traverser, ++vmanager++. A viewlet manager would be accessible (as rendered HTML) at a location such as http://localhost:8080/mysite/myobject/++vmanager++ITop. This is the traverser code:<br /></p>

<pre>from zope.publisher.interfaces.browser import IBrowserView<br />from zope.traversing.interfaces import TraversalError<br />from zope import component<br />from zope.interface import implements<br />from zope.traversing.namespace import SimpleHandler<br />from zope.viewlet.interfaces import IViewletManager<br /><br />class vmanager(SimpleHandler):<br />    implements(IBrowserView)<br />    def __init__(self, context, request):<br />        self.context = context<br />        self.request = request<br />        <br />    def traverse(self, name, ignored):<br />        manager = component.queryMultiAdapter((self.context, self.request, self), IViewletManager, name=name)<br />        if manager:<br />            return manager<br />        else:<br />            raise TraversalError(self.context, name)<br /></pre><p>The traverser is registered like this:</p><p></p><pre>&lt;adapter<br />		name="vmanager" for="*"<br />		provides="zope.traversing.interfaces.ITraversable" <br />		factory=".namespace.vmanager"<br />		/&gt;<br />		<br />	&lt;view<br />		name="vmanager" for="*"<br />		type="zope.interface.Interface"<br />		provides="zope.traversing.interfaces.ITraversable" <br />		factory=".namespace.vmanager"<br />		/&gt;<br /></pre><p>The traverse() in the vmanager class will return the manager. One thing to note is that once the manager returned, Zope will try to get the default view for this object, so a default page (index.html) is needed for IViewletManager</p><pre>class ViewViewletManager(object):<br />    """View a rendered viewlet manager"""<br />    <br />    def __call__(self):<br />        manager = self.context<br />        manager.update()<br />        return manager.render()<br /></pre><p>This page is registered as </p><p></p><pre>&lt;browser:page<br />		name="index.html"<br />		class=".browser.ViewViewletManager"<br />		for="zope.viewlet.interfaces.IViewletManager"<br />		permission="zope.View"<br />		/&gt;<br /></pre><p>Next, to automate things a bit more, I wrote a template, along these lines:</p><pre>&lt;tal:vars<br />    tal:define="vmgr_name view/__name__; here_url context/@@absolute_url"&gt;<br />    &lt;div id="provider_ITop"<br />        tal:attributes="id string:provider_$vmgr_name"&gt;<br />        &lt;div tal:repeat="viewlet view/viewlets" tal:omit-tag=""&gt;<br />            &lt;div tal:replace="structure viewlet/render" /&gt;<br />        &lt;/div&gt;<br />    &lt;/div&gt;<br />    &lt;script<br />        tal:content="string:<br />function reload_${vmgr_name}(){<br />    new Ajax.Updater('provider_${vmgr_name}', '$here_url/++vmanager++${vmgr_name}')<br />}" /&gt;<br />&lt;/tal:vars&gt;</pre>

<p>This template inserts the viewlet contents in a named container and creates a JavaScript function (which uses Prototype) that can be called later to update that container. The last piece is to tell my viewlet providers to use this template (observe the template argument):</p><pre>&lt;viewletManager name="IFooter" provides=".IFooterSlotManager"<br />        class="z3c.viewlet.manager.WeightOrderedViewletManager"<br />        template="vmanager.pt"<br />        permission="zope.View" /&gt;<br /></pre><p>I'll probably still have to write some views and JavaScript to make things dynamics, but this solution will sure help to reduce the amount of code I have to write.</p>
