+++
draft = false
date = "2007-02-27T17:09:31-02:00"
title = "I hate brackets! (or rants of a JavaScript novice programmer)"
tags = ["rants", "Javascript"]
created = "2007-02-27T16:45:08-02:00"
modified = "2007-04-14T23:52:17-03:00"
permaLink = "http://play.pixelblaster.ro/blog/archive/2007/02/27/i-hate-brackets-or-rants-of-a-javascript-novice-programmer"
author = "Tiberiu Ichim"
aliases = [
    "/blog/archive/2007/02/27/i-hate-brackets-or-rants-of-a-javascript-novice-programmer"
]
+++

<p>Javascript is nice, I'm having fun building this Zope3/Ajax based application that I'm working on right now. What I don't enjoy is the forest of non-alphanumeric characters that has started to clog my code. I'm really a novice when it comes to Javascript, most of my professional programming has been done with other languages, but look for example at this fragment of code:</p><pre>    for (i=0; i&lt; parent.childNodes.length; i++) {<br />        el = parent.childNodes.item(i)<br />        if(el.nodeType == Node.ELEMENT_NODE) {<br />            if (el.classNames().find(function(s){return s == 'ajax_response'}))<br />            {<br />                parent.removeChild(parent.childNodes.item(i));<br />            }<br />        }<br />    }</pre><p>It's a simple snippet that checks if there's already an "ajax_response" container in the parent container.  On line 4 I've stretched the code as much as I could, already reaching 80 characters (I'm using Prototype, the reasons there's an anonymous function as parameter to the find(), applied on an Enumerator object). The code is ugly and hard to read and comprehend. I'm really beginning to appreciate Python, a python version would have been something like this (trying not to differ too much from the JS version):</p><pre>for i in range(parent.childNodes.length()):<br />    el = parent.childNodes[i]<br />    if el.nodeType is Node.ELEMENT_NODE) and \<br />         'ajax_response' in el.classNames():<br />                parent.removeChild(parent.childNodes.item(i))<br /></pre><p>The block of code have been reduced to almost half the number of lines and I dare say that now it is really possible to read an understand this snippet. Probably the JS code could be improved as well, but I'll keep such optimizations for later on, when my Js-Foo gets better.</p><h3>Updated (again)<br /></h3><p>I wrote a Prototype extension to create a "scrollable area". I've modeled the code after the <a href="http://livepipe.net/projects/control_tabs/">Control.Tabs</a> extension. The control is almost ready. I feel good after understanding JS's OOP system and the Prototype extensions, its bind/bindAsEventListener quirks, but the code remains the same unreadable mess, when compared to Python code.<br /></p><pre>sizeToNumber = function(size){<br />	//converts a style size (ex: 10px) to a number. Hackish method<br />	return size.substring(0, size.length -2) * 1<br />}<br /><br />if(typeof(Control) == "undefined")<br />	var Control = {};<br />Control.Scroller = Class.create();<br />Object.extend(Control.Scroller.prototype, {<br />	container:false,<br />	initialize:function(area, options){<br /><br />		// set the options<br />		this.options = $H({<br />			timeslice:0.1,<br />			amount:5, <br />			type:'vertical',<br />			width:'500px',<br />			height:'400px'<br />		}).merge(options || {});<br />		this.area = $(area);<br />		this.sid = 'scroller' + this.area.id;<br />		// insert the control structures<br />		new Insertion.After(this.area, <br />			"&lt;div class='scroller " + this.options.type + "' id='" + this.sid + "'&gt;" +<br />				"&lt;div class='sb b_A' id='" + this.sid + "sb'&gt;&lt;/div&gt;" + <br />				"&lt;div class='s_outer'&gt;" +<br />					"&lt;div class='s_inner'&gt;&lt;/div&gt;" + <br />				"&lt;/div&gt;" + <br />				"&lt;div class='sb b_B' id='" + this.sid + "sr'&gt;&lt;/div&gt;" +<br />			"&lt;/div&gt;"<br />		);<br />					<br />		// div scroller  &lt;- container for the entire control<br />		// div sb b_A    &lt;- scroll button. b_A = button A, b_B = button B<br />		// div s_outer   &lt;- The restricted visible portion of the scrolled content. Has overflow:hidden<br />		// div s_inner	 &lt;- Container which holds the actual content<br /><br />		inner = $(this.sid).down('.s_inner');<br />		outer = $(this.sid).down('.s_outer');<br />		<br />		inner.appendChild(this.area);<br />		outer.style.overflow = 'hidden';<br />		// TODO: only apply one of height/weight<br /><br />		switch (this.options.type) {<br />			case 'vertical':<br />				this.direction = 'marginTop';<br />				outer.style.height = this.options.height;				<br />				inner.style.height = this.area.clientHeight + 'px';<br />				break<br />			case 'horizontal':<br />				this.direction = 'marginLeft';<br />				outer.style.width = this.options.width;<br />				inner.style.width = this.area.clientWidth + 'px';<br />				break<br />			default:<br />				throw ("Unsported orientation/style type") <br />		}<br />				<br />		//event handlers LEFT (or TOP) scroll button<br />		$(this.sid).down('.b_A').observe('mousedown', function(event){<br />			this.flag=true;<br />			new PeriodicalExecuter(function(pe){<br />				if (this.flag) {<br />				  	this.doScroll(this.options.amount);<br />				} else {<br />				  	pe.stop();<br />				}<br />	    	}.bind(this), this.options.timeslice);<br />		}.bindAsEventListener(this));<br />		$(this.sid).down('.b_A').observe('mouseup', function(event){<br />			this.flag = false;<br />		}.bindAsEventListener(this));<br />		<br />		//event handlers RIGHT (or BOTTOM) scroll button<br />		$(this.sid).down('.b_B').observe('mousedown', function(event){<br />			this.flag=true;<br />			new PeriodicalExecuter(function(pe){<br />				if (this.flag) {<br />					inner = $(this.sid).down('.s_inner');<br />					cl_height = sizeToNumber(this.options.height);	// the scroller control area<br />					delta = sizeToNumber(inner.style[this.direction]);	// how much the inner div was scrolled<br />					if (this.options.type == 'horizontal') {<br />						direction = 'clientWidth'<br />					} else if (this.options.type == 'vertical'){<br />						direction = 'clientHeight'<br />					}<br />					re_size = this.area[direction];		// the real content size (the ideal size)<br />					if (!(((delta * -1) + cl_height) &gt;= re_size)) {<br />						this.doScroll(this.options.amount * -1);<br />					}<br />				} else {<br />				  	pe.stop();<br />				}<br />	    	}.bind(this), this.options.timeslice);<br />		}.bindAsEventListener(this));<br />		$(this.sid).down('.b_B').observe('mouseup', function(event){<br />			this.flag = false;<br />		}.bindAsEventListener(this));<br />	},<br /><br />	doScroll:function(amount){<br />		// do a scroll in the direction specified<br />		delta = $(this.sid).down('.s_inner').style[this.direction];<br />		if (!delta) {<br />			delta = "0px";<br />		}<br />		numeric_delta = sizeToNumber(delta) + amount;<br />		if ( numeric_delta &gt; 0) {return}<br />		delta = numeric_delta + "px";<br />		$(this.sid).down('.s_inner').style[this.direction] = delta;<br />	},<br />	<br />	scrollToElement:function(target_id){<br />		// scroll to a specified id element inside the area<br />		<br />		switch (this.options.type) {<br />			case 'vertical': <br />				offsetType = 'offsetTop';<br />				break;<br />			case 'horizontal':<br />				offsetType = 'offsetLeft';<br />				break;<br />		}<br />		target_offset = $(target_id)[offsetType];	//distance to top of page for the target container<br />		outer_offset = $(this.sid).down('.s_outer')[offsetType];<br />		offset_from_top = target_offset - outer_offset;<br /><br />		this._to_scroll = offset_from_top;<br />		this._incr = Math.ceil(Math.abs(offset_from_top) / 2);<br />		new PeriodicalExecuter(<br />			function(pe){<br />				if (this._to_scroll &lt;= this._incr) {<br />					multiplier = 1<br />				} else {<br />					multiplier = -1<br />				}<br />				this.doScroll(multiplier * this._incr);<br />				this._to_scroll += multiplier * this._incr;<br />				this._incr = Math.ceil(this._incr / 2);<br />				window.console.log(this._incr);				<br />				if (this._to_scroll * multiplier * -1 &lt;= this._incr) {<br />					this.doScroll(-1 * this._to_scroll);	//the last scroll<br />					pe.stop()<br />				}<br />			}.bind(this), <br />			this.options.timeslice<br />		);<br />		return false;<br />	}<br />})<br /></pre>
