<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.20.2" />

  <meta name="google-site-verification" content="hhGMo4F_Uk22qjSxDH4EDkMsLh6gDQnytKz2l6kb3aE" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  <title>The Plone Expanse - a Zope/Plone blog by Tiberiu Ichim</title>
  

  
  <link rel="stylesheet" href="/css/poole.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="stylesheet" href="/css/hyde.css">

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/gruvbox-dark.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="The Plone Expanse" />

</head>

<body class=" ">

  <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="/"><h1>The Plone Expanse </h1></a>
      <p class="lead">
       A bit of Plone, Zope and a dash of everything else 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><i class='fa fa-home' aria-hidden='true'></i> <a href="/">Home</a> </li>
      
      <li><i class='fa fa-calendar' aria-hidden='true'></i> <a href="/archive">Archive </a></li>
      
      <li><i class='fa fa-tags' aria-hidden='true'></i> <a href="/tags">Tags </a></li>
      
      <li><i class='fa fa-rss' aria-hidden='true'></i> <a href="/index.xml">Subscribe by RSS </a></li>
      
      <li><i class='fa fa-github-alt' aria-hidden='true'></i> <a href="https://github.com/tiberiuichim">Github </a></li>
      
      <li> <a href="/blog/2022/02/06/custom-volto-configuration-to-fix-babel-problems-with-react-leaflet/">Custom Volto configuration to fix Babel problems with react-leaflet </a></li>
      
      <li> <a href="/blog/2022/07/18/volto-recipe-for-footer-actions-managed-as-site-content/">Volto recipe for footer actions managed as site content </a></li>
      
    </ul>

    <p>@2019 Tiberiu Ichim</p>
  </div>
</div>


  <div class="content container">
    <section class="posts">
      
      

      
      <div class="post">
        <h2 class="post-title"><a href="/blog/2022/07/18/volto-recipe-for-footer-actions-managed-as-site-content/">Volto recipe for footer actions managed as site content</a></h2>

        <p class="post-tags">
          <i class='fa fa-tags' aria-hidden='true'></i>
          <a href="/tags/cookbook">cookbook</a>, <a href="/tags/plone">Plone</a>, <a href="/tags/volto">Volto</a>
        </p>

        <span class="post-date"><time>Jul 18, 2022</time></span>

        <p class="discreet">Managing the Footer as content is one of the common tasks on a Plone / Volto website. One typical approach is to designate some root folder, let&rsquo;s say footer-links as a container for Link instances, and use those links as shortcuts to dedicated pages.
So, a footer component may look like this:
import React from 'react'; import { getContent } from '@plone/volto/actions'; import { useSelector } from 'react-redux'; import {UniversalLink} from '@plone/volto/components'; const Footer = () =&gt; { const footerLinks = useSelector((state) =&gt; state. [...]</p>

        <div class="read-more-link">
          <a href="/blog/2022/07/18/volto-recipe-for-footer-actions-managed-as-site-content/">Read More&rarr;</a>
        </div>

      </div>
      
      

      
      <div class="post">
        <h2 class="post-title"><a href="/blog/2022/02/06/custom-volto-configuration-to-fix-babel-problems-with-react-leaflet/">Custom Volto configuration to fix Babel problems with react-leaflet</a></h2>

        <p class="post-tags">
          <i class='fa fa-tags' aria-hidden='true'></i>
          <a href="/tags/cookbook">cookbook</a>, <a href="/tags/plone">Plone</a>, <a href="/tags/volto">Volto</a>
        </p>

        <span class="post-date"><time>Feb 6, 2022</time></span>

        <p class="discreet">I&rsquo;ve started working on a new Leaflet-powered Volto map block and the first thing that happened while loading react-leaftlet was an error reported by the browser:
Module parse failed: Unexpected token (10:41) in @react-leaflet/core/esm/path.js ... const options = props.pathOptions ?? {}; ...  The problem is that is, for some reasons, the transpiled JS bundle includes code using the nulish coalescing operator
This is already a problem reported in react-leaflet and it happens because the distributed transpiled library includes that code. [...]</p>

        <div class="read-more-link">
          <a href="/blog/2022/02/06/custom-volto-configuration-to-fix-babel-problems-with-react-leaflet/">Read More&rarr;</a>
        </div>

      </div>
      
      

      
      <div class="post">
        <h2 class="post-title"><a href="/blog/2019/12/11/a-volto-gotcha-when-dealing-with-async-calls/">A Volto gotcha when dealing with async calls</a></h2>

        <p class="post-tags">
          <i class='fa fa-tags' aria-hidden='true'></i>
          <a href="/tags/plone">Plone</a>, <a href="/tags/volto">Volto</a>
        </p>

        <span class="post-date"><time>Dec 11, 2019</time></span>

        <p class="discreet">Just some quick notes, in case this might help someone. After quite a bit of time and tests in trying to use asyncConnect to get data in a Volto component view (strictly focusing on the SSR side), I&rsquo;ve realized that what I&rsquo;m trying to do is not supported by the redux-connect library.
In Volto, right now there are two components that use asyncConnect: App.jsx and Search.jsx. The purpose of asyncConnect is to have the server side rendered page &ldquo;dynamic&rdquo;, depending on the input from the originating request. [...]</p>

        <div class="read-more-link">
          <a href="/blog/2019/12/11/a-volto-gotcha-when-dealing-with-async-calls/">Read More&rarr;</a>
        </div>

      </div>
      
      

      
      <div class="post">
        <h2 class="post-title"><a href="/blog/2019/11/17/speedup-volto-razzle-builds/">Speedup volto razzle builds</a></h2>

        <p class="post-tags">
          <i class='fa fa-tags' aria-hidden='true'></i>
          <a href="/tags/plone">Plone</a>, <a href="/tags/volto">Volto</a>, <a href="/tags/razzle">Razzle</a>, <a href="/tags/webpack">webpack</a>, <a href="/tags/cookbook">cookbook</a>
        </p>

        <span class="post-date"><time>Nov 17, 2019</time></span>

        <p class="discreet">I&rsquo;ve been looking for a way to speedup Volto razzle/webpack builds, both while developing and for &ldquo;production&rdquo; mode, when building the final bundle. Fortunately, this solution exists and it&rsquo;s extremely easy to integrate.
Let&rsquo;s define the problem, to see how to approach it: what is Volto actually? What do you get when you open, in your browser, a Volto frontend Plone website? To greatly simplify (and I hope I didn&rsquo;t get anything wrong as I am not a Volto core developer): [...]</p>

        <div class="read-more-link">
          <a href="/blog/2019/11/17/speedup-volto-razzle-builds/">Read More&rarr;</a>
        </div>

      </div>
      
      

      
      <div class="post">
        <h2 class="post-title"><a href="/blog/2017/12/18/a-quick-and-dirty-mini-plugin-system-for-python/">A quick and dirty mini-plugin system for Python</a></h2>

        <p class="post-tags">
          <i class='fa fa-tags' aria-hidden='true'></i>
          <a href="/tags/python">Python</a>, <a href="/tags/cookbook">cookbook</a>
        </p>

        <span class="post-date"><time>Dec 18, 2017</time></span>

        <p class="discreet">Inspired by Pyramid&rsquo;s and venusian&rsquo;s scan() call, I&rsquo;ve reimplemented an auto-discovery system for plugins. The problem is simple.
Suppose we want to &ldquo;register&rdquo; a series of functions that can run automatically, based on aspects set in the calling environment. The simples and easiest solution is something like:
# in some module, as a global declaration: from somethingA import runner_A from somethingB import runner_B runners = [ runner_A, runner_B ] # then, maybe in some function: def main(): # . [...]</p>

        <div class="read-more-link">
          <a href="/blog/2017/12/18/a-quick-and-dirty-mini-plugin-system-for-python/">Read More&rarr;</a>
        </div>

      </div>
      
      

      
      <div class="post">
        <h2 class="post-title"><a href="/blog/2017/09/06/identifying-and-fixing-broken-objects-in-a-plone-website/">Identifying and fixing broken objects in a Plone website</a></h2>

        <p class="post-tags">
          <i class='fa fa-tags' aria-hidden='true'></i>
          <a href="/tags/plone">Plone</a>, <a href="/tags/programming">programming</a>, <a href="/tags/cookbook">cookbook</a>, <a href="/tags/tutorial">tutorial</a>
        </p>

        <span class="post-date"><time>Sep 6, 2017</time></span>

        <p class="discreet">I&rsquo;ve removed plone.app.stagingbehavior from a website because the new plone.app.iterate has the same functionality. In addition, the p.a.s package was overriding adapters that I wanted to write.
Now, my problem was that I could no longer save any related items, I would get an error:
Module ZPublisher.Publish, line 138, in publish Module ZPublisher.mapply, line 77, in mapply Module ZPublisher.Publish, line 48, in call_object Module plone.z3cform.layout, line 66, in __call__ Module plone. [...]</p>

        <div class="read-more-link">
          <a href="/blog/2017/09/06/identifying-and-fixing-broken-objects-in-a-plone-website/">Read More&rarr;</a>
        </div>

      </div>
      
      

      
      <div class="post">
        <h2 class="post-title"><a href="/blog/2017/08/15/my-recipe-for-cronjobs-with-docker/">My recipe for cronjobs with Docker</a></h2>

        <p class="post-tags">
          <i class='fa fa-tags' aria-hidden='true'></i>
          <a href="/tags/docker">Docker</a>, <a href="/tags/cookbook">cookbook</a>, <a href="/tags/rancher">Rancher</a>, <a href="/tags/cron">cron</a>
        </p>

        <span class="post-date"><time>Aug 15, 2017</time></span>

        <p class="discreet">One of the bigger annoyances when it comes to bigger application stacks (such as the typical Plone/Zope) is dealing with cron jobs and, in general, async tasks. The problem is that of the number of &ldquo;pieces&rdquo;: having to deal with cron, in addition to the rest of the stack only increases the maintainance burden: it&rsquo;s easy to forget that the stack needs to have cronjobs installed, etc. One way to avoid it is to include the cron jobs in the stack, with a buildout recipe. [...]</p>

        <div class="read-more-link">
          <a href="/blog/2017/08/15/my-recipe-for-cronjobs-with-docker/">Read More&rarr;</a>
        </div>

      </div>
      
      

      
      <div class="post">
        <h2 class="post-title"><a href="/blog/2017/08/14/running-pyramid-with-flask-in-the-same-python-process/">Running Pyramid with Flask, in the same Python process</a></h2>

        <p class="post-tags">
          <i class='fa fa-tags' aria-hidden='true'></i>
          <a href="/tags/flask">Flask</a>, <a href="/tags/pyramid">Pyramid</a>, <a href="/tags/cookbook">cookbook</a>, <a href="/tags/python">python</a>
        </p>

        <span class="post-date"><time>Aug 14, 2017</time></span>

        <p class="discreet">Thanks to the wonders of WSGI and well behaved frameworks, it is now trivial to mix and match applications and have them run in the same Python process.
Normally, in a production scenario, uwsgi would be used to split and map the URL spaces to different apps, but for development it is simpler to just use good old PythonPaste. In my case, I&rsquo;ve wanted to have the RQ Dashboard (which is based on Flask) integrated with a Pyramid app that I&rsquo;m working on. [...]</p>

        <div class="read-more-link">
          <a href="/blog/2017/08/14/running-pyramid-with-flask-in-the-same-python-process/">Read More&rarr;</a>
        </div>

      </div>
      
      

      
      <div class="post">
        <h2 class="post-title"><a href="/blog/2017/08/03/restore-missing-blobs-from-blob-cache/">Restore missing blobs from blob cache</a></h2>

        <p class="post-tags">
          <i class='fa fa-tags' aria-hidden='true'></i>
          <a href="/tags/cookbook">cookbook</a>, <a href="/tags/plone">Plone</a>, <a href="/tags/zope">Zope</a>, <a href="/tags/python">Python</a>
        </p>

        <span class="post-date"><time>Aug 3, 2017</time></span>

        <p class="discreet">I had a curious case of missing-but-present blobs in an old Plone service, configured with a Zeo server and 2 Zope instances.
The root of the problem (I think) was that the blob folder configuration was broken: the Zope client instances were configured with shared blobs to &ldquo;off&rdquo;, but they were really sharing the same caching folder.
In the end, the blobs were loaded by the Zope services and everything appeared to be working, but when I&rsquo;ve tried to move the blobstorage folder to a new machine, I ended up with missing blobs. [...]</p>

        <div class="read-more-link">
          <a href="/blog/2017/08/03/restore-missing-blobs-from-blob-cache/">Read More&rarr;</a>
        </div>

      </div>
      
      

      
      <div class="post">
        <h2 class="post-title"><a href="/blog/2017/05/08/restart-docker-after-archlinux-upgrade/">Restart docker after archlinux upgrade</a></h2>

        <p class="post-tags">
          <i class='fa fa-tags' aria-hidden='true'></i>
          <a href="/tags/cookbook">cookbook</a>, <a href="/tags/linux">Linux</a>
        </p>

        <span class="post-date"><time>May 8, 2017</time></span>

        <p class="discreet">My main reason for avoiding ArchLinux upgrades (sudo pacman -Syu) was because I always needed to reboot my computer, to allow starting docker services after the upgrade. Today, I found the solution is a simple:
systemctl daemon-reload systemctl restart docker   [...]</p>

        <div class="read-more-link">
          <a href="/blog/2017/05/08/restart-docker-after-archlinux-upgrade/">Read More&rarr;</a>
        </div>

      </div>
      
      

      <nav id="page-nav">

    
    <a href="/">Home</a>
    
        <a class="extend next" rel="next" href="/page/2/">
             Next »
        </a>
    

</nav>

    </section>
  </div>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>
<script>
  jQuery(document).ready(function() {
    $('pre').each(function(i, block) {
      hljs.highlightBlock(block);
    });
  });
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-104721960-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>
